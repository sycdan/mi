[user]
	name = Dan Stace

[push]
	default = simple

[alias]
	aa = add --all
	ad = add
	ass = add
	# interactive branch switcher
	brco = "!f() { git branch | pick | xargs git co; }; f"
	# delete current branch after checking out main
	brdel = "!f() { B=$(git brname); git co main; git branch -D $B; }; f"
	brname = rev-parse --abbrev-ref HEAD
	ca = commit --amend
	cm = commit -m
	co = checkout
	cor = "!f() { git fetch origin && git checkout origin/$1; }; f"
	cob = checkout -b
	# Interactive checkout
	coi = "!f() { \
		branch=$(git branch | grep -v '*' | sed 's/^..//' | pick -q \"$1\"); \
		if [ -z \"$branch\" ]; then \
			echo \"No branch selected.\"; \
			exit 1; \
		fi; \
		git switch \"$branch\"; \
	}; f"
	# Detached interactive checkout
	cod = "!f() { \
		matches=$(git ls-remote --heads origin | sed 's|^.*refs/heads/||' | grep \"$1\"); \
		if [ -z \"$matches\" ]; then \
			echo \"No remote branches found containing: $1\"; \
			exit 1; \
		fi; \
		count=$(echo \"$matches\" | wc -l); \
		if [ \"$count\" -eq 1 ]; then \
			branch=\"$matches\"; \
		else \
			branch=$(echo \"$matches\" | pick); \
		fi; \
		if [ -z \"$branch\" ]; then \
			echo \"No branch selected.\"; \
			exit 1; \
		fi; \
		git fetch origin \"$branch\" && git checkout FETCH_HEAD; \
	}; f"
	desc = describe
	# fixup the last commit
	f = rebase --interactive HEAD~2
	af = "!f() { \
		base=$(git log --pretty=format:'%H %s' | awk '/^.* f$/{next} {print $1; exit}'); \
		if [ -z \"$base\" ]; then echo 'No base commit found.'; exit 1; fi; \
		echo "Autofixuping onto $base"; \
		GIT_SEQUENCE_EDITOR=\"sed -i 's/^pick \\([0-9a-f]*\\) f$/fixup \\1 f/'\" \
		git rebase -i $base^; \
	}; f"
	fp = "push --force-with-lease"
	fpx = "!f() { B=$(git brname); if [ \"$B\" = \"main\" ]; then git push --force-with-lease; else git push origin --delete $B; git push origin $B; fi; }; f"
	git = !exec git
	l = log --oneline
	ls = ls-files

	# updates the timestamp of the last commit to an offset from now
	time = "!f() { git commit --amend --no-edit --date=\"$(date -d \"$1\")\"; }; f"
	now = !git time now
	
	# Show the root of the repo
	root = rev-parse --show-toplevel

	repo = "!f() { branch=$(git brname 2> /dev/null); if [ -n \"$branch\" ] ; then if [ \"$branch\" = \"HEAD\" ] ; then if git status | grep 'rebase in progress' > /dev/null ; then branch='rebase'; else branch=$(git describe --always); fi; fi; echo $(basename $(git rev-parse --show-toplevel)):$branch; else exit 1; fi; }; f"
	rba = rebase --abort
	rbc = rebase --continue
	rbi = rebase --interactive
	rbr = rebase --interactive --root
	s = status -s

	# determines if the current branch has been pushed or not
	pushed = "!f() { [[ \"$(git show-ref refs/heads/$(git brname) | cut '-d ' -f1)\" = \"$(git show-ref refs/remotes/origin/$(git brname) | cut '-d ' -f1)\" ]]; }; f"

	# generate list indexes
	st = !git -c color.ui=always status -sb | git pick -t file '^\\s*[AMDRU?]+\\s*(?:.* -> )?(.*)'
	br = !git -c color.ui=always branch "$@" | git pick -t rev '^\\s+(\\S*).*'
	slog = !git -c color.ui=always log --pretty=simple "$@" | git pick -t rev '^(?:.*\\dm)?(\\w+) .*'

	# act on file list indexes
	r = pick -t file restore
	d = pick -t file diff
	a = pick -t file -r add
	del = pick -t file -r clean -f
	unstage = pick -t file reset HEAD
	
	# remove from git, but keep the file
	untrack = pick -t file rm --cached

	ignore = pick -t file update-index --assume-unchanged
	unignore = pick -t file update-index --no-assume-unchanged

[web]
	# mac
	# open = xdg-open
	# sudo apt install wslu
	open = wslview

[color]
	ui = auto

[core]
	filemode = false
	autocrlf = false
	safecrlf = false
	editor = code --wait
	# hooksPath = ~/dotfiles/git/hooks
	excludesfile = ~/dotfiles/git/ignore_global

[remote "origin"]
	prune = true

[fetch]
	prune = true

[pull]
	rebase = true

[gitflow]
	multi-hotfix = true

[init]
	defaultBranch = main

[diff]
	tool = vscode

[difftool "vscode"]
	cmd = code --wait --diff $LOCAL $REMOTE

[merge]
	tool = vscode

[mergetool "vscode"]
	cmd = code --wait $MERGED
